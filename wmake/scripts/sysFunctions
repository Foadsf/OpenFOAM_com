#----------------------------------*-sh-*--------------------------------------
# =========                 |
# \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
#  \\    /   O peration     |
#   \\  /    A nd           | www.openfoam.com
#    \\/     M anipulation  |
#------------------------------------------------------------------------------
#     Copyright (C) 2018-2020 OpenCFD Ltd.
#------------------------------------------------------------------------------
# License
#     This file is part of OpenFOAM, distributed under GPL-3.0-or-later.
#
# Script
#     sysFunctions
#
# Description
#     General system helper functions
#
# Functions provided
#     isDarwin
#     isNone
#     isSystem
#     isAbsdir, hasAbsdir
#     findFirstFile
#     thirdExtLib
#     versionCompare
#
# Variables provided
#     extLiba
#     extLibso
#
#------------------------------------------------------------------------------

if [ -z "$WMAKE_SCRIPTS_SYSFUNCTIONS" ]
then
    # Load once, but do not rely on this variable elsewhere
    WMAKE_SCRIPTS_SYSFUNCTIONS=loaded

    # Static library extension. Default=.a
    extLiba=".a"

    # Shared library extension. Default=.so
    case "$(uname -s 2>/dev/null)" in
    Darwin)
        extLibso=".dylib"
        ;;
    *)
        extLibso=".so"
        ;;
    esac


    # True if OS is Darwin.
    # Uses libso extension to cache the value
    # (instead of calling 'uname -s' each time)
    isDarwin()
    {
        test "$extLibso" = ".dylib"
    }


    # True if '$1' begins with '/'
    isAbsdir()
    {
        test "$1" = "/${1#/}"
    }


    # True if '$1' begins with '/' and also exists as a directory
    hasAbsdir()
    {
        test "$1" = "/${1#/}" -a -d "$1"
    }


    # True if '$1' is an empty string or matches "*-none".
    # Eg,
    #    if isNone "$KAHIP_ARCH_PATH" ...
    isNone()
    {
        test -z "$1" -o "${1##*-}" = none
    }


    # True if '$1' matches "*-system"
    # Eg,
    #    if isSystem "$BOOST_ARCH_PATH"
    isSystem()
    {
        test "${1##*-}" = system
    }


    # Check for the existence of any of the files
    # On success, echoes the file found and returns 0, otherwise returns 2
    findFirstFile()
    {
        local file
        for file
        do
            if [ -f "$file" -a -r "$file" ]
            then
                echo "$file"
                return 0
            fi
        done
        return 2
    }

    # Check for existence of file in FOAM_EXT_LIBBIN,
    # but not if either file or FOAM_EXT_LIBBIN are empty or
    # if the FOAM_EXT_LIBBIN is not located in the ThirdParty directory
    #
    # On success, echoes the resolved file and returns 0, otherwise returns 2
    thirdExtLib()
    {
        local file="$FOAM_EXT_LIBBIN/$1"

        if  [ -n "$1" ] && \
            [ -n "$FOAM_EXT_LIBBIN" ] && \
            [ -n "$WM_THIRD_PARTY_DIR" ] && \
            [ -f "$file" -a -r "$file" ] && \
            [ "${FOAM_EXT_LIBBIN#$WM_THIRD_PARTY_DIR}" != "$FOAM_EXT_LIBBIN" ]
        then
            echo "$file"
        else
            return 2
        fi
    }


    # Compare version tuples with syntax similar to POSIX shell,
    # but respecting dot separators.
    #
    # arg1 OP arg2
    #   OP is one of -eq, -ne, -lt, -le, -gt, or -ge.
    #   Returns true for a successful comparison.
    #   Arg1 and arg2 normally comprise positive integers, but leading content
    #   before a '-' is stripped.
    #   Missing digits are treated as '0'.
    #
    # Eg,
    #    versionCompare "software-1.2.3" -gt 1.1 && echo True
    #
    # Ad hoc handling of "git" version as always newest.
    #    "git" -gt "1.2.3" : True
    #    "1.2.3" -lt "git" : True
    versionCompare()
    {
        [ "$#" -eq 3 ] || {
            echo "Compare needs 3 arguments (was given $#)" 1>&2
            return 2
        }

        local arg1="${1#*-}"    # Strip leading prefix-
        local op="${2}"
        local arg2="${3#*-}"    # Strip leading prefix-
        local result=''         # Empty represents 'equal'

        arg1="${arg1:-0}."
        arg2="${arg2:-0}."

        if   [ "$arg1" = "$arg2" ];        then unset arg1 arg2 # Identical
        elif [ "${arg1#git}" != "$arg1" ]; then result='more'   # (git > arg2)
        elif [ "${arg2#git}" != "$arg2" ]; then result='less'   # (arg1 < git)
        fi

        while [ -z "$result" ] && [ -n "${arg1}${arg2}" ]
        do
            local digits1="${arg1%%.*}"
            local digits2="${arg2%%.*}"

            arg1="${arg1#*.}"
            arg2="${arg2#*.}"

            : "${digits1:=0}"
            : "${digits2:=0}"

            # Other handling of non-integer values?
            if   [ "$digits1" -lt "$digits2" ]; then result='less'
            elif [ "$digits1" -gt "$digits2" ]; then result='more'
            fi
        done

        case "$op" in
        (-eq | eq)  [ -z "$result" ] ;;
        (-ne | ne)  [ -n "$result" ] ;;
        (-lt | lt)  [ 'less' = "$result" ] ;;
        (-gt | gt)  [ 'more' = "$result" ] ;;
        (-le | le)  [ 'less' = "${result:-less}" ] ;;
        (-ge | ge)  [ 'more' = "${result:-more}" ] ;;
        (*)
            echo "Unknown operator: '$op'" 1>&2
            return 2
            ;;
        esac
    }
fi


#------------------------------------------------------------------------------
